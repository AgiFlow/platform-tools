version: '1.0'
template: typescript-lib
description: Rules and patterns for typescript-lib template
rules:
  - pattern: src/services/**/*.ts
    description: Service Layer Implementation Standards
    inherits:
      - export-standards
      - error-handling
      - type-safety
      - async-await-patterns
    must_do:
      - rule: Create class-based services with single responsibility
        codeExample: |-
          export class DataProcessorService {
            async processData(input: string): Promise<ProcessedData> {
              // Implementation
            }
          }
      - rule: Use dependency injection for composability
        codeExample: |-
          export class UserService {
            constructor(
              private readonly apiClient: ApiClient,
              private readonly cache: CacheService
            ) {}
          }
      - rule: Return typed results - never use any
        codeExample: |-
          async getData(): Promise<DataResult> {
            return { success: true, data: [] };
          }
      - rule: Handle errors with try-catch
        codeExample: |-
          async fetchData(id: string): Promise<Data> {
            try {
              return await this.api.get(id);
            } catch (error) {
              throw new Error(`Failed to fetch: ${error.message}`);
            }
          }
    must_not_do:
      - rule: Create static-only utility classes - use functions
        codeExample: |-
          // ❌ BAD
          export class Utils {
            static format(s: string) {}
          }

          // ✅ GOOD
          export function format(s: string): string {}
      - rule: Mix multiple unrelated concerns in one service
        codeExample: |-
          // ❌ BAD
          export class AppService {
            parseData() {}
            sendEmail() {}
            saveToDb() {}
          }
      - rule: Use synchronous blocking operations for I/O
  - pattern: src/utils/**/*.ts
    description: Utility Functions Standards
    inherits:
      - export-standards
      - type-safety
      - documentation-standards
    must_do:
      - rule: Use pure functions - no side effects
        codeExample: |-
          export function formatDate(date: Date): string {
            return date.toISOString();
          }

          export function calculateTotal(items: Item[]): number {
            return items.reduce((sum, item) => sum + item.price, 0);
          }
      - rule: Add JSDoc for complex utilities
        codeExample: |-
          /**
           * Formats a number as currency
           * @param amount - The amount to format
           * @param currency - Currency code (default: USD)
           * @returns Formatted currency string
           */
          export function formatCurrency(amount: number, currency = 'USD'): string {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency }).format(amount);
          }
      - rule: Keep functions small and focused - single purpose
        codeExample: |-
          // ✅ GOOD - Focused functions
          export function trim(str: string): string
          export function capitalize(str: string): string
          export function slugify(str: string): string
    must_not_do:
      - rule: Create utility classes - use functions instead
        codeExample: |-
          // ❌ BAD
          export class StringUtils {
            static trim(s: string) {}
          }

          // ✅ GOOD
          export function trim(s: string): string {}
      - rule: Use any type - always specify types
        codeExample: |-
          // ❌ BAD
          export function process(data: any) {}

          // ✅ GOOD
          export function process<T>(data: T): T {}
      - rule: Add side effects in utility functions
        codeExample: |-
          // ❌ BAD - Side effect (modifies global state)
          export function log(msg: string) {
            console.log(msg); // Side effect!
          }

          // ✅ GOOD - Pure function
          export function formatMessage(msg: string): string {
            return `[LOG] ${msg}`;
          }
  - pattern: src/types/**/*.ts
    description: Type Definitions Standards
    inherits:
      - export-standards
      - type-safety
      - documentation-standards
    must_do:
      - rule: Define clear interfaces for all data structures
        codeExample: |-
          export interface User {
            id: string;
            email: string;
            name: string;
            createdAt: Date;
          }

          export interface ApiResponse<T> {
            success: boolean;
            data?: T;
            error?: string;
          }
      - rule: Use TypeScript utility types for transformations
        codeExample: |-
          export type PartialUser = Partial<User>;
          export type RequiredUser = Required<User>;
          export type UserKeys = keyof User;
          export type UserProfile = Pick<User, 'name' | 'email'>;
      - rule: Add JSDoc for complex types
        codeExample: |-
          /**
           * Configuration options for the library
           * @property timeout - Request timeout in ms
           * @property retries - Number of retry attempts
           */
          export interface Config {
            timeout: number;
            retries: number;
          }
    must_not_do:
      - rule: Use any type - use unknown or proper types
        codeExample: |-
          // ❌ BAD
          export interface Result {
            data: any;
          }

          // ✅ GOOD
          export interface Result<T = unknown> {
            data: T;
          }
      - rule: Create types without exports
        codeExample: |-
          // ❌ BAD
          interface Config {} // Not exported

          // ✅ GOOD
          export interface Config {}
      - rule: Mix implementation with types
        codeExample: |-
          // ❌ BAD
          export class MyClass {}
          export interface MyInterface {}

          // ✅ GOOD - Only types
          export interface MyInterface {}
          export type MyType = {};
  - pattern: tests/**/*.test.ts
    description: Test Standards with Vitest
    inherits:
      - type-safety
    must_do:
      - rule: Use descriptive test names with 'should' pattern
        codeExample: |-
          import { describe, it, expect } from 'vitest';

          describe('formatCurrency', () => {
            it('should format number as USD currency', () => {
              expect(formatCurrency(1000)).toBe('$1,000.00');
            });

            it('should handle zero amount', () => {
              expect(formatCurrency(0)).toBe('$0.00');
            });
          });
      - rule: Test both success and error paths
        codeExample: |-
          it('should return data on success', async () => {
            const result = await service.getData();
            expect(result.success).toBe(true);
          });

          it('should handle errors gracefully', async () => {
            await expect(service.getData()).rejects.toThrow('Error');
          });
      - rule: Mock external dependencies
        codeExample: |-
          import { vi } from 'vitest';

          const mockApi = {
            fetch: vi.fn().mockResolvedValue({ data: 'test' })
          };

          const service = new MyService(mockApi);
    must_not_do:
      - rule: Test implementation details - test behavior
        codeExample: |-
          // ❌ BAD - Testing implementation
          expect(service.privateMethod).toBeDefined();

          // ✅ GOOD - Testing behavior
          expect(service.process(input)).toBe(expected);
      - rule: Use hardcoded values - use test data
        codeExample: |-
          // ❌ BAD
          const userId = '123';

          // ✅ GOOD
          const userId = faker.string.uuid();
      - rule: Skip edge cases and error scenarios
  - pattern: src/services/index.ts
    description: Service Layer Barrel Export Standards
    must_do:
      - rule: Export all services from index.ts using barrel exports
        codeExample: |-
          export { UserService } from './UserService';
          export { ProductService } from './ProductService';
          export { OrderService } from './OrderService';
      - rule: Group related services together in exports
        codeExample: |-
          // Domain services
          export { UserService } from './UserService';
          export { OrderService } from './OrderService';

          // Utility services
          export { EmailService } from './EmailService';
          export { CacheService } from './CacheService';
    must_not_do:
      - rule: Include service implementation in index.ts - only exports
        codeExample: |-
          // ❌ BAD - Implementation in barrel file
          export class UserService { async getAll() {} }

          // ✅ GOOD - Only exports
          export { UserService } from './UserService';
      - rule: Use wildcard exports - be explicit
        codeExample: |-
          // ❌ BAD
          export * from './UserService';

          // ✅ GOOD
          export { UserService } from './UserService';
  - pattern: src/utils/index.ts
    description: Utility Functions Barrel Export Standards
    must_do:
      - rule: Export all utility functions from index.ts using barrel exports
        codeExample: |-
          export { formatDate, parseDate } from './dateUtils';
          export { validateEmail, sanitizeInput } from './validationUtils';
          export { chunk, debounce, throttle } from './arrayUtils';
      - rule: Group utilities by category in exports
        codeExample: |-
          // Date utilities
          export { formatDate, parseDate } from './dateUtils';

          // Validation utilities
          export { validateEmail, sanitizeInput } from './validationUtils';

          // Array utilities
          export { chunk, debounce, throttle } from './arrayUtils';
    must_not_do:
      - rule: Include utility implementation in index.ts - only exports
        codeExample: |-
          // ❌ BAD - Implementation in barrel file
          export function formatDate(date: Date) { return date.toISOString(); }

          // ✅ GOOD - Only exports
          export { formatDate } from './dateUtils';
      - rule: Use wildcard exports - be explicit
        codeExample: |-
          // ❌ BAD
          export * from './dateUtils';

          // ✅ GOOD
          export { formatDate, parseDate } from './dateUtils';
  - pattern: src/types/index.ts
    description: Type Definitions Barrel Export Standards
    must_do:
      - rule: Export all types, interfaces, and type utilities from index.ts
        codeExample: |-
          export type { User, UserRole, UserPermissions } from './user';
          export type { Product, ProductCategory } from './product';
          export type { ApiResponse, ApiError } from './api';
      - rule: Group related types together in exports
        codeExample: |-
          // User types
          export type { User, UserRole, UserPermissions } from './user';

          // Product types
          export type { Product, ProductCategory } from './product';

          // API types
          export type { ApiResponse, ApiError } from './api';
    must_not_do:
      - rule: Include type definitions in index.ts - only exports
        codeExample: |-
          // ❌ BAD - Definition in barrel file
          export type User = { id: string; name: string; };

          // ✅ GOOD - Only exports
          export type { User } from './user';
      - rule: Use wildcard type exports - be explicit
        codeExample: |-
          // ❌ BAD
          export * from './user';

          // ✅ GOOD
          export type { User, UserRole } from './user';
  - pattern: src/constants/**/*.constants.ts
    description: Constants Module Standards
    inherits:
      - export-standards
      - type-safety
      - documentation-standards
    must_do:
      - rule: Use UPPER_SNAKE_CASE for primitive constants
        codeExample: |-
          export const DEFAULT_TIMEOUT = 5000;
          export const MAX_RETRIES = 3;
          export const API_VERSION = 'v1';
      - rule: Use PascalCase with 'as const' for object constants
        codeExample: |-
          export const ApiConfig = {
            baseUrl: 'https://api.example.com',
            timeout: 5000,
            retries: 3,
          } as const;

          export const ErrorCodes = {
            NOT_FOUND: 404,
            UNAUTHORIZED: 401,
            SERVER_ERROR: 500,
          } as const;
      - rule: Export inferred types for object constants
        codeExample: |-
          export const StatusConfig = {
            PENDING: 'pending',
            COMPLETED: 'completed',
            FAILED: 'failed',
          } as const;

          export type Status = typeof StatusConfig[keyof typeof StatusConfig];
      - rule: Add JSDoc comments for all exported constants
        codeExample: |-
          /**
           * Maximum number of retry attempts for API calls
           * @default 3
           */
          export const MAX_RETRIES = 3;

          /**
           * API endpoint configuration
           * @property baseUrl - Base URL for API calls
           * @property timeout - Request timeout in milliseconds
           */
          export const ApiConfig = {
            baseUrl: 'https://api.example.com',
            timeout: 5000,
          } as const;
      - rule: Group related constants in const objects
        codeExample: |-
          export const HttpConfig = {
            timeout: 5000,
            retries: 3,
            headers: {
              'Content-Type': 'application/json',
            },
          } as const;
    must_not_do:
      - rule: Use mutable exports (let or var)
        codeExample: |-
          // ❌ BAD - Mutable
          export let API_URL = 'https://api.example.com';

          // ✅ GOOD - Immutable
          export const API_URL = 'https://api.example.com';
      - rule: Export magic numbers without context
        codeExample: |-
          // ❌ BAD - No context
          export const TIMEOUT = 5000;

          // ✅ GOOD - Clear purpose
          /**
           * Default timeout for HTTP requests in milliseconds
           */
          export const DEFAULT_HTTP_TIMEOUT = 5000;
      - rule: Mix unrelated constants in same file
        codeExample: |-
          // ❌ BAD - Mixing HTTP, database, and email configs
          export const HTTP_TIMEOUT = 5000;
          export const DB_POOL_SIZE = 10;
          export const EMAIL_FROM = 'noreply@example.com';

          // ✅ GOOD - Separate by domain
          // http.constants.ts
          export const HTTP_TIMEOUT = 5000;
          // db.constants.ts
          export const DB_POOL_SIZE = 10;
      - rule: Create objects without 'as const' assertion
        codeExample: |-
          // ❌ BAD - No type safety
          export const Config = {
            apiUrl: 'https://api.example.com',
          };

          // ✅ GOOD - Type-safe with 'as const'
          export const Config = {
            apiUrl: 'https://api.example.com',
          } as const;
  - pattern: src/constants/index.ts
    description: Constants Barrel Export Standards
    must_do:
      - rule: Export all constants from index.ts using barrel exports
        codeExample: |-
          export * from './api.constants';
          export * from './config.constants';
          export * from './errors.constants';
      - rule: Group related constants together in exports
        codeExample: |-
          // API constants
          export * from './api.constants';
          export * from './endpoints.constants';

          // Configuration constants
          export * from './config.constants';
          export * from './env.constants';

          // Error constants
          export * from './errors.constants';
          export * from './statusCodes.constants';
      - rule: Re-export types from constant files
        codeExample: |-
          export * from './api.constants';
          export type { ApiConfigType, EndpointKeys } from './api.constants';
    must_not_do:
      - rule: Include constant definitions in index.ts - only exports
        codeExample: |-
          // ❌ BAD - Definition in barrel file
          export const API_URL = 'https://api.example.com';

          // ✅ GOOD - Only exports
          export * from './api.constants';
      - rule: Selectively export some constants - export all
        codeExample: |-
          // ❌ BAD - Selective exports
          export { API_URL } from './api.constants'; // Missing other exports

          // ✅ GOOD - Export all
          export * from './api.constants';
